# Consumer (Order Service) - Kafka message consumer
#
# SHARED NETWORK APPROACH: Joins external ecommerce-network
#
# How it works:
#   - Network created at root level (docker-compose.yml)
#   - Both producer and consumer join the same ecommerce-network
#   - Consumer accesses Kafka at: kafka:29092 (internal network)
#   - Spring Kafka handles retries if Kafka not ready yet
#   - Background monitoring keeps checking Kafka
#   - Auto-connects when Kafka becomes available
#
# DEPLOYMENT:
#   docker compose up -d
#
# STARTUP MODES:
#   - Consumer can start first (waits for Kafka with exponential backoff)
#   - Producer can start first (immediate Kafka connection)
#   - Both simultaneously (both handle gracefully)
#
# PORTS:
#   8082  - Order Service (Consumer API)

services:
  # Order Service (Consumer) - Processes order events from Kafka
  order-service:
    image: y0ncha/eda-consumer:2.0.0
    container_name: order-service
    ports:
      - "8082:8082"  # Consumer API
    environment:
      # Connect to Kafka via shared Docker network (internal)
      # kafka:29092 is the internal PLAINTEXT listener
      # Spring Kafka will handle retries if Kafka not ready yet
      SPRING_KAFKA_BOOTSTRAP_SERVERS: kafka:29092
      SPRING_KAFKA_CONSUMER_GROUP_ID: order-service-group
      KAFKA_TOPIC: orders
      LOGGING_LEVEL_ROOT: INFO
      LOGGING_LEVEL_MTA_EDA_CONSUMER: DEBUG
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8082/order-service/health/live" ]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 20s
    networks:
      - ecommerce-network
    restart: on-failure

# Shared network (created manually: docker network create ecommerce-network)
# Both producer and consumer join this network
networks:
  ecommerce-network:
    driver: bridge
    external: true
    name: ecommerce-network

